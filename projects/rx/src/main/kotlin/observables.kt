package nl.komponents.kovenant.rx

import nl.komponents.kovenant.*
import rx.Observable
import rx.Subscriber
import java.util.*


enum class EmitStrategy {
    FIRST, LAST
}



fun <V> Observable<V>.toPromise(context: Context = Kovenant.context,
                                strategy: EmitStrategy = EmitStrategy.FIRST,
                                emptyFactory: () -> V)
        : Promise<V, Exception> = toPromise(context, strategy, EmptyPolicy.resolve(emptyFactory))

fun <V> Observable<V>.toPromise(context: Context = Kovenant.context,
                                strategy: EmitStrategy = EmitStrategy.FIRST,
                                emptyPolicy: EmptyPolicy<V, Exception> = EmptyPolicy.default()): Promise<V, Exception> {
    val subscriber: PromiseSubscriber<V> = when (strategy) {
        EmitStrategy.FIRST -> FirstValueSubscriber(context, emptyPolicy)
        EmitStrategy.LAST -> LastValueSubscriber(context, emptyPolicy)
    }
    subscribe(subscriber)
    return subscriber.promise
}

fun <V> Observable<V>.toListPromise(context: Context = Kovenant.context): Promise<List<V>, Exception> {
    val observer = ListValuesSubscriber<V>(context)
    subscribe(observer)
    return observer.promise
}

private abstract class PromiseSubscriber<V> : Subscriber<V>() {
    abstract val promise: Promise<V, Exception>
}

private class FirstValueSubscriber<V>(context: Context,
                                      private val emptyPolicy: EmptyPolicy<V, Exception>) : PromiseSubscriber<V>() {
    private val deferred = deferred<V, Exception>(context)
    override val promise: Promise<V, Exception> = deferred.promise

    override fun onNext(value: V) {
        deferred.resolve(value)
        unsubscribe()
    }

    override fun onError(error: Throwable?) = deferred.reject(error.asException())
    override fun onCompleted() = emptyPolicy.apply(deferred)
}

private class LastValueSubscriber<V>(context: Context,
                                     private val emptyPolicy: EmptyPolicy<V, Exception>) : PromiseSubscriber<V>() {
    //Rx always executes on same thread/worker, no need to sync
    private var value: V? = null
    private var hasValue = false

    private val deferred = deferred<V, Exception>(context)
    override val promise: Promise<V, Exception> = deferred.promise

    override fun onNext(value: V) {
        this.value = value
        hasValue = true
    }

    override fun onError(error: Throwable?) = deferred.reject(error.asException())
    override fun onCompleted() {
        if (hasValue) {
            deferred.resolve(value as V)
        } else {
            emptyPolicy.apply(deferred)
        }
    }
}

interface EmptyPolicy<V, E> {
    companion object {
        private val default = FactoryRejectPolicy<Any>() {
            EmptyException("completed without elements")
        }

        @Suppress("UNCHECKED_CAST")
        fun <V> default(): EmptyPolicy<V, Exception> = default as EmptyPolicy<V, Exception>

        /**
         * Creates an `EmptyPolicy` that resolves as successful with the value
         * generated by the `factory`
         */
        fun <V> resolve(factory: () -> V): EmptyPolicy<V, Exception> = FactoryResolvePolicy(factory)

        /**
         * Creates an `EmptyPolicy` that resolves as successful with the provided value
         */
        fun <V> resolve(value: V): EmptyPolicy<V, Exception> = ValueResolvePolicy(value)

        /**
         * Creates an `EmptyPolicy` that resolves as failed with the error
         * generated by the `factory`
         */
        fun <V> reject(factory: () -> Exception): EmptyPolicy<V, Exception> = FactoryRejectPolicy(factory)

        /**
         * Creates an `EmptyPolicy` that resolves as failed with the provided error
         */
        fun <V> reject(error: Exception): EmptyPolicy<V, Exception> = ValueRejectPolicy(error)
    }

    fun apply(deferred: Deferred<V, E>)
}

private class FactoryRejectPolicy<V>(private val factory: () -> Exception) : EmptyPolicy<V, Exception> {

    override fun apply(deferred: Deferred<V, Exception>) {
        deferred.reject(factory())
    }
}

private class FactoryResolvePolicy<V>(private val factory: () -> V) : EmptyPolicy<V, Exception> {
    override fun apply(deferred: Deferred<V, Exception>) {
        deferred.resolve(factory())
    }
}

private class ValueResolvePolicy<V>(private val value: V) : EmptyPolicy<V, Exception> {
    override fun apply(deferred: Deferred<V, Exception>) {
        deferred.resolve(value)
    }
}

private class ValueRejectPolicy<V>(private val error: Exception) : EmptyPolicy<V, Exception> {
    override fun apply(deferred: Deferred<V, Exception>) {
        deferred.reject(error)
    }
}


private class ListValuesSubscriber<V>(context: Context) : Subscriber<V>() {
    //Rx always executes on same thread/worker, no need to sync
    private var values: MutableList<V> = ArrayList()

    private val deferred = deferred<List<V>, Exception>(context)
    val promise: Promise<List<V>, Exception> = deferred.promise

    override fun onNext(value: V) {
        values.add(value)
    }

    override fun onError(error: Throwable?) = deferred.reject(error.asException())
    override fun onCompleted() = deferred.resolve(values)
}


fun Throwable?.asException(): Exception = if (this is Exception) this else RuntimeException(this)

